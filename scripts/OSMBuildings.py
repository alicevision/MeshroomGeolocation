from argparse import ArgumentParser
import trimesh
import numpy as np
import json
from math import *
import math
import requests
import geopandas as gpd
from shapely import Polygon
import logging
import logLevel

# Parsing of all arguments
def buildArgumentParser() -> ArgumentParser:
    ap = ArgumentParser()
    ap.add_argument("--method", help="method of furnishing gps data", type=str)
    ap.add_argument("--GPSFile", help="gps file generated by the perfect node", type=str)
    ap.add_argument("--latInputPoint", help="latitude custom if the method is custom", type=float)
    ap.add_argument("--lonInputPoint", help="longitude custom if the method is custom", type=float)
    ap.add_argument("--verboseLevel", help="verbose level for logging", type=str)
    ap.add_argument("--geoJson", help="output GeoJson file", type=str)
    ap.add_argument("--outputObj", help="output obj", type=str)
    return ap

# Agent header for the request
agentheader = {'User-Agent': 'PostmanRuntime/7.28.4'}

def coordinatesToUse(method, args):
    #what method of localisation
    if method == "auto":
        # Opening JSON file
        with open(args.GPSFile, 'r') as inputfile:
            # Reading from json file
            json_object = json.load(inputfile)
        
        latitude = json_object["latitude"]
        longitude = json_object["longitude"]

        return (latitude, longitude)
    else:
        return (args.latInputPoint, args.lonInputPoint)
    
#conversion of the longitude and latitude into tiles
def deg2num(lat_deg, lon_deg, zoom):
  lat_rad = math.radians(lat_deg)
  n = 2.0 ** zoom
  xtile = int((lon_deg + 180.0) / 360.0 * n)
  ytile = int((1.0 - math.asinh(math.tan(lat_rad)) / math.pi) / 2.0 * n)
  return (xtile, ytile)

def internetRequestOSM(xtile, ytile, zoom):
    # Request on OSM Buildings
    url = "https://data.osmbuildings.org/0.2/anonymous/tile/{0}/{1}/{2}.json".format(zoom, xtile, ytile) 

    response = requests.get(url,headers = agentheader)
    return json.loads(response.text)

def getPolygonsAndHeightsFromGeojson(geoJson):
    # Get the polygons and heights in the GeoJSON
    gdf = gpd.read_file(geoJson)

    buildings_geojson = []
    heights_geojson = []

    for polygon in gdf[gdf.geometry.type == "Polygon"].geometry:
        buildings_geojson.append(Polygon(polygon.exterior.coords))
        
    for height in gdf.height:
        heights_geojson.append(height)
    
    return buildings_geojson, heights_geojson
    
def trimeshScene(buildings_mesh, heights, position_x, position_y, scale):
    #add all mesh to a scene
    scene = trimesh.Scene()

    for i in range(len(buildings_mesh)):
        mesh = trimesh.creation.extrude_polygon(buildings_mesh[i], heights[i])
        
        #relocate the mesh to align to the camera position
        mesh.apply_transform(trimesh.transformations.rotation_matrix(np.deg2rad(90), [1, 0, 0]))
        mesh.apply_transform(trimesh.transformations.rotation_matrix(np.deg2rad(180), [0, 0, 1]))
        mesh.apply_transform(trimesh.transformations.rotation_matrix(np.deg2rad(180), [0, 1, 0]))
        mesh.apply_transform(trimesh.transformations.translation_matrix([-position_x, 0, position_y]))

        scale_matrix = np.diag([scale, scale*10, scale, 1])
        mesh.apply_transform(scale_matrix)
        scene.add_geometry(mesh)
    
    return scene

#convert longitude and latitude into distance in meters with Haversine method
def haversine(lon1, lat1, lon2, lat2):
    R = 6371000

    lon1, lat1, lon2, lat2 = map(math.radians, [lon1, lat1, lon2, lat2])
    delta_lon = lon2 - lon1
    delta_lat = lat2 - lat1

    a = math.sin(delta_lat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(delta_lon / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = R * c

    return distance

# download new zone
def add_geojson(args, zoom, xtile, ytile):
    new_data = json.loads(requests.get("https://data.osmbuildings.org/0.2/anonymous/tile/{0}/{1}/{2}.json".format(zoom, xtile, ytile), headers=agentheader).text)
    
    with open(args.geoJson) as f:
        current_data = json.load(f)

    current_data['features'].extend(new_data['features'])

    with open(args.geoJson, 'w') as f:
        json.dump(current_data, f)

def add_data(args):
    gdf = gpd.read_file(args.geoJson)

    buildings_geojson_extended = []
    heights_geojson_extended = []

    for polygon in gdf[gdf.geometry.type == "Polygon"].geometry:
        buildings_geojson_extended.append(Polygon(polygon.exterior.coords))
        
    for height in gdf.height:
        heights_geojson_extended.append(height)
    
    max_x, max_y = 0, 0
    for i in range(len(buildings_geojson_extended)):
        if max(buildings_geojson_extended[i].exterior.coords.xy[0]) > max_x:
            max_x = max(buildings_geojson_extended[i].exterior.coords.xy[0])
        if max(buildings_geojson_extended[i].exterior.coords.xy[1]) > max_y:
            max_y = max(buildings_geojson_extended[i].exterior.coords.xy[1])
            
    min_x, min_y = max_x, max_y
    for i in range(len(buildings_geojson_extended)):
        if min(buildings_geojson_extended[i].exterior.coords.xy[0]) < min_x:
            min_x = min(buildings_geojson_extended[i].exterior.coords.xy[0])
        if min(buildings_geojson_extended[i].exterior.coords.xy[1]) < min_y:
            min_y = min(buildings_geojson_extended[i].exterior.coords.xy[1])
            
    buildings_geojson = buildings_geojson_extended
    heights_geojson = heights_geojson_extended
    
    return buildings_geojson, heights_geojson


def main():
    ap = buildArgumentParser()
    args = ap.parse_args()

    logging.basicConfig(level=logLevel.textToLogLevel(args.verboseLevel))

    logging.info("Buildings extruded !")

    location = coordinatesToUse(args.method, args)

    # Calculate tile corresponding
    lat_deg, lon_deg = location[0], location[1]
    zoom = 15
    xtile, ytile = deg2num(lat_deg=lat_deg, lon_deg=lon_deg, zoom=zoom)

    data = internetRequestOSM(xtile, ytile, zoom)

    # Export the GeoJSON
    with open(args.geoJson, 'w') as f:
        json.dump(data, f)

    buildings_geojson, heights_geojson = getPolygonsAndHeightsFromGeojson(args.geoJson)

    # Convert the coordinates for the mesh
    factor = 10000
    max_heights = max(heights_geojson)

    buildings_mesh = []

    #find the max x and y to relocate the mesh
    max_x, max_y = 0, 0
    for building in buildings_geojson:
        if max(building.exterior.coords.xy[0]) > max_x:
            max_x = max(building.exterior.coords.xy[0])
        if max(building.exterior.coords.xy[1]) > max_y:
            max_y = max(building.exterior.coords.xy[1])

    min_x, min_y = max_x, max_y
    for i in range(len(buildings_geojson)):
        if min(buildings_geojson[i].exterior.coords.xy[0]) < min_x:
            min_x = min(buildings_geojson[i].exterior.coords.xy[0])
        if min(buildings_geojson[i].exterior.coords.xy[1]) < min_y:
            min_y = min(buildings_geojson[i].exterior.coords.xy[1])


    # Calculate the distance between the min and max x and y
    x_pos = haversine(min_x, location[0], location[1], location[0])
    y_pos = haversine(location[1], min_y, location[1], location[0])

    box_width = haversine(min_x, min_y, max_x, min_y)
    box_height = haversine(min_x, min_y, min_x, max_y)

    # Check if in the edges
    on_left_edge = x_pos < box_width / 3
    on_right_edge = x_pos > box_width * 2/3
    on_bottom_edge = y_pos < box_height / 3
    on_top_edge = y_pos > box_height * 2/3

    # Detect which tiles are needed
    if on_left_edge:
        new_xtile = xtile - 1  
        add_geojson(args, zoom, new_xtile, ytile)
        if on_bottom_edge:
            new_ytile = ytile + 1
            add_geojson(args, zoom, new_xtile, new_ytile)
        if on_top_edge:
            new_ytile = ytile - 1
            add_geojson(args, zoom, new_xtile, new_ytile)
    if on_right_edge:
        new_xtile = xtile + 1
        add_geojson(args, zoom, new_xtile, ytile)
        if on_bottom_edge:
            new_ytile = ytile + 1
            add_geojson(args, zoom, new_xtile, new_ytile)
        if on_top_edge:
            new_ytile = ytile - 1
            add_geojson(args, zoom, new_xtile, new_ytile)
    if on_top_edge:
        new_ytile = ytile - 1
        add_geojson(args, zoom, xtile, new_ytile)
    if on_bottom_edge:
        new_ytile = ytile + 1
        add_geojson(args, zoom, xtile, new_ytile)

    buildings_geojson, heights_geojson = add_data(args)


    #convert the coordinates of the buildings
    for building in buildings_geojson:
        tab = []
        for x, y in building.exterior.coords:
            x = x - max_x
            y = y - max_y
            x = x * factor
            y = y * factor
            x = round(x, 3)
            y = round(y, 3)
            tab.append((x, y))
        buildings_mesh.append(Polygon(tab))

    #convert the heights of the buildings
    for i in range(len(heights_geojson)):
        heights_geojson[i] = heights_geojson[i] / max_heights

    #convert camera position the same way
    position_x = location[1]
    position_x -= max_x
    position_x *= factor
    position_x = round(position_x, 3)

    position_y = location[0]
    position_y -= max_y
    position_y *= factor
    position_y = round(position_y, 3)

    distance = haversine(min_x, min_y, max_x, max_y)
    scale_factor = factor / distance

    scene = trimeshScene(buildings_mesh, heights_geojson, position_x, position_y, scale_factor)

    #export the Obj
    with open(args.outputObj, 'w') as file:
        scene.export(
            file,
            file_type='obj',
        )
        
    logging.info("Buildings extruded generated")

if __name__ == "__main__":
    main()