from argparse import ArgumentParser
import trimesh
import numpy as np
import json
from math import *
import math
import requests
import geopandas as gpd
from shapely import Polygon
import logging
import logLevel

# Parsing of all arguments
def buildArgumentParser() -> ArgumentParser:
    ap = ArgumentParser()
    ap.add_argument("--method", help="method of furnishing gps data", type=str)
    ap.add_argument("--GPSFile", help="gps file generated by the perfect node", type=str)
    ap.add_argument("--latInputPoint", help="latitude custom if the method is custom", type=float)
    ap.add_argument("--lonInputPoint", help="longitude custom if the method is custom", type=float)
    ap.add_argument("--verboseLevel", help="verbose level for logging", type=str)
    ap.add_argument("--geoJson", help="output GeoJson file", type=str)
    ap.add_argument("--outputObj", help="output obj", type=str)
    return ap

def coordinatesToUse(method, args):
    #what method of localisation
    if method == "auto":
        # Opening JSON file
        with open(args.GPSFile, 'r') as inputfile:
            # Reading from json file
            json_object = json.load(inputfile)
        
        latitude = json_object["latitude"]
        longitude = json_object["longitude"]

        return (latitude, longitude)
    else:
        return (args.latInputPoint, args.lonInputPoint)
    
#conversion of the longitude and latitude into tiles
def deg2num(lat_deg, lon_deg, zoom):
  lat_rad = math.radians(lat_deg)
  n = 2.0 ** zoom
  xtile = int((lon_deg + 180.0) / 360.0 * n)
  ytile = int((1.0 - math.asinh(math.tan(lat_rad)) / math.pi) / 2.0 * n)
  return (xtile, ytile)

def internetRequestOSM(xtile, ytile, zoom):
    # Request on OSM Buildings
    url = "https://data.osmbuildings.org/0.2/anonymous/tile/{0}/{1}/{2}.json".format(zoom, xtile, ytile) 
    agentheader = {'User-Agent': 'PostmanRuntime/7.28.4'}

    response = requests.get(url,headers = agentheader)
    return json.loads(response.text)

def getPolygonsAndHeightsFromGeojson(geoJson):
    # Get the polygons and heights in the GeoJSON
    gdf = gpd.read_file(geoJson)

    buildings_geojson = []
    heights_geojson = []

    for polygon in gdf[gdf.geometry.type == "Polygon"].geometry:
        buildings_geojson.append(Polygon(polygon.exterior.coords))
        
    for height in gdf.height:
        heights_geojson.append(height)
    
    return buildings_geojson, heights_geojson
    
def trimeshScene(buildings_mesh, heights, position_x, position_y):
    #add all mesh to a scene
    scene = trimesh.Scene()

    for i in range(len(buildings_mesh)):
        mesh = trimesh.creation.extrude_polygon(buildings_mesh[i], heights[i])
        
        #relocate the mesh to align to the camera position
        mesh.apply_transform(trimesh.transformations.rotation_matrix(np.deg2rad(90), [1, 0, 0]))
        mesh.apply_transform(trimesh.transformations.rotation_matrix(np.deg2rad(180), [0, 0, 1]))
        mesh.apply_transform(trimesh.transformations.rotation_matrix(np.deg2rad(180), [0, 1, 0]))
        mesh.apply_transform(trimesh.transformations.translation_matrix([-position_x, 0, position_y]))

        # TODO : find a way to scale the mesh to the real world
        mesh.apply_transform(trimesh.transformations.scale_matrix(2))
        scene.add_geometry(mesh)
    
    return scene

def main():
    ap = buildArgumentParser()
    args = ap.parse_args()

    logging.basicConfig(level=logLevel.textToLogLevel(args.verboseLevel))

    logging.info("Buildings extruded !")

    location = coordinatesToUse(args.method, args)

    # Calculate tile corresponding
    lat_deg, lon_deg = location[0], location[1]
    zoom = 15
    xtile, ytile = deg2num(lat_deg=lat_deg, lon_deg=lon_deg, zoom=zoom)

    data = internetRequestOSM(xtile, ytile, zoom)

    # Export the GeoJSON
    with open(args.geoJson, 'w') as f:
        json.dump(data, f)

    buildings_geojson, heights_geojson = getPolygonsAndHeightsFromGeojson(args.geoJson)

    # Convert the coordinates for the mesh
    factor = 1000
    max_heights = max(heights_geojson)

    buildings_mesh = []

    #find the max x and y to relocate the mesh
    max_x, max_y = 0, 0
    for building in buildings_geojson:
        if max(building.exterior.coords.xy[0]) > max_x:
            max_x = max(building.exterior.coords.xy[0])
        if max(building.exterior.coords.xy[1]) > max_y:
            max_y = max(building.exterior.coords.xy[1])

    #convert the coordinates of the buildings
    for building in buildings_geojson:
        tab = []
        for x, y in building.exterior.coords:
            x = x - max_x
            y = y - max_y
            x = x * factor
            y = y * factor
            x = round(x, 3)
            y = round(y, 3)
            tab.append((x, y))
        buildings_mesh.append(Polygon(tab))

    #convert the heights of the buildings
    for i in range(len(heights_geojson)):
        heights_geojson[i] = heights_geojson[i] / max_heights

    #convert camera position the same way
    position_x = location[1]
    position_x -= max_x
    position_x *= factor
    position_x = round(position_x, 3)

    position_y = location[0]
    position_y -= max_y
    position_y *= factor
    position_y = round(position_y, 3)

    scene = trimeshScene(buildings_mesh, heights_geojson, position_x, position_y)

    #export the Obj
    with open(args.outputObj, 'w') as file:
        scene.export(
            file,
            file_type='obj',
        )
        
    #TODO si on est sur un bord de map, récupérer les maps autour, faire un paramètre

    logging.info("Buildings extruded generated")

if __name__ == "__main__":
    main()